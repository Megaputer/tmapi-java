/*
 * Megaputer Text Mining API
 * Megaputer Text Mining API
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package tmapi.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import tmapi.model.TokensResponsePosition;

/**
 * TokensResponseTokens
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2019-12-20T13:29:48.384+03:00[Europe/Moscow]")
public class TokensResponseTokens {
  public static final String SERIALIZED_NAME_WORD = "word";
  @SerializedName(SERIALIZED_NAME_WORD)
  private String word;

  public static final String SERIALIZED_NAME_LEMMA = "lemma";
  @SerializedName(SERIALIZED_NAME_LEMMA)
  private String lemma;

  /**
   * Assigns a word to a morphological category according to each syntactic functions.
   */
  @JsonAdapter(PartOfSpeechEnum.Adapter.class)
  public enum PartOfSpeechEnum {
    NOUN("Noun"),
    
    VERB("Verb"),
    
    ADVERB("Adverb"),
    
    ADJECTIVE("Adjective"),
    
    PARTICLE("Particle"),
    
    PRONOUN("Pronoun"),
    
    NUMERAL("Numeral"),
    
    SPECIAL("Special"),
    
    PUNCTUATION("Punctuation");

    private String value;

    PartOfSpeechEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PartOfSpeechEnum fromValue(String text) {
      for (PartOfSpeechEnum b : PartOfSpeechEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + text + "'");
    }

    public static class Adapter extends TypeAdapter<PartOfSpeechEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PartOfSpeechEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PartOfSpeechEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return PartOfSpeechEnum.fromValue(String.valueOf(value));
      }
    }
  }

  public static final String SERIALIZED_NAME_PART_OF_SPEECH = "partOfSpeech";
  @SerializedName(SERIALIZED_NAME_PART_OF_SPEECH)
  private PartOfSpeechEnum partOfSpeech;

  public static final String SERIALIZED_NAME_MODIFIER = "modifier";
  @SerializedName(SERIALIZED_NAME_MODIFIER)
  private Object modifier = null;

  /**
   * Indicates a way of writing a token with the previous one. It returns \&quot;1\&quot;, if tokens are written as a single token. It returns \&quot;0\&quot;, if tokens are written separately. 
   */
  @JsonAdapter(IsExtensionEnum.Adapter.class)
  public enum IsExtensionEnum {
    NUMBER_0(0),
    
    NUMBER_1(1);

    private Integer value;

    IsExtensionEnum(Integer value) {
      this.value = value;
    }

    public Integer getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static IsExtensionEnum fromValue(String text) {
      for (IsExtensionEnum b : IsExtensionEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + text + "'");
    }

    public static class Adapter extends TypeAdapter<IsExtensionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final IsExtensionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public IsExtensionEnum read(final JsonReader jsonReader) throws IOException {
        Integer value = jsonReader.nextInt();
        return IsExtensionEnum.fromValue(String.valueOf(value));
      }
    }
  }

  public static final String SERIALIZED_NAME_IS_EXTENSION = "isExtension";
  @SerializedName(SERIALIZED_NAME_IS_EXTENSION)
  private IsExtensionEnum isExtension;

  public static final String SERIALIZED_NAME_POSITION = "position";
  @SerializedName(SERIALIZED_NAME_POSITION)
  private TokensResponsePosition position = null;

  public TokensResponseTokens word(String word) {
    this.word = word;
    return this;
  }

   /**
   * Word as in text
   * @return word
  **/
  @ApiModelProperty(example = "Elvis", value = "Word as in text")
  public String getWord() {
    return word;
  }

  public void setWord(String word) {
    this.word = word;
  }

  public TokensResponseTokens lemma(String lemma) {
    this.lemma = lemma;
    return this;
  }

   /**
   * A dictionary form of a word, e.g. given verb forms \&quot;run\&quot;, \&quot;ran\&quot; and \&quot;runs\&quot;, \&quot;run\&quot; is the lemma
   * @return lemma
  **/
  @ApiModelProperty(example = "Elvis", value = "A dictionary form of a word, e.g. given verb forms \"run\", \"ran\" and \"runs\", \"run\" is the lemma")
  public String getLemma() {
    return lemma;
  }

  public void setLemma(String lemma) {
    this.lemma = lemma;
  }

  public TokensResponseTokens partOfSpeech(PartOfSpeechEnum partOfSpeech) {
    this.partOfSpeech = partOfSpeech;
    return this;
  }

   /**
   * Assigns a word to a morphological category according to each syntactic functions.
   * @return partOfSpeech
  **/
  @ApiModelProperty(example = "Noun", value = "Assigns a word to a morphological category according to each syntactic functions.")
  public PartOfSpeechEnum getPartOfSpeech() {
    return partOfSpeech;
  }

  public void setPartOfSpeech(PartOfSpeechEnum partOfSpeech) {
    this.partOfSpeech = partOfSpeech;
  }

  public TokensResponseTokens modifier(Object modifier) {
    this.modifier = modifier;
    return this;
  }

   /**
   * One of the grammatical categories of a word, e.g. person for verbs or number for nouns. Each part of speech has its own set of modifiers.  The detailed list of parameters can be found in Help to TM API Server. 
   * @return modifier
  **/
  @ApiModelProperty(value = "One of the grammatical categories of a word, e.g. person for verbs or number for nouns. Each part of speech has its own set of modifiers.  The detailed list of parameters can be found in Help to TM API Server. ")
  public Object getModifier() {
    return modifier;
  }

  public void setModifier(Object modifier) {
    this.modifier = modifier;
  }

  public TokensResponseTokens isExtension(IsExtensionEnum isExtension) {
    this.isExtension = isExtension;
    return this;
  }

   /**
   * Indicates a way of writing a token with the previous one. It returns \&quot;1\&quot;, if tokens are written as a single token. It returns \&quot;0\&quot;, if tokens are written separately. 
   * @return isExtension
  **/
  @ApiModelProperty(value = "Indicates a way of writing a token with the previous one. It returns \"1\", if tokens are written as a single token. It returns \"0\", if tokens are written separately. ")
  public IsExtensionEnum getIsExtension() {
    return isExtension;
  }

  public void setIsExtension(IsExtensionEnum isExtension) {
    this.isExtension = isExtension;
  }

  public TokensResponseTokens position(TokensResponsePosition position) {
    this.position = position;
    return this;
  }

   /**
   * Get position
   * @return position
  **/
  @ApiModelProperty(value = "")
  public TokensResponsePosition getPosition() {
    return position;
  }

  public void setPosition(TokensResponsePosition position) {
    this.position = position;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TokensResponseTokens tokensResponseTokens = (TokensResponseTokens) o;
    return Objects.equals(this.word, tokensResponseTokens.word) &&
        Objects.equals(this.lemma, tokensResponseTokens.lemma) &&
        Objects.equals(this.partOfSpeech, tokensResponseTokens.partOfSpeech) &&
        Objects.equals(this.modifier, tokensResponseTokens.modifier) &&
        Objects.equals(this.isExtension, tokensResponseTokens.isExtension) &&
        Objects.equals(this.position, tokensResponseTokens.position);
  }

  @Override
  public int hashCode() {
    return Objects.hash(word, lemma, partOfSpeech, modifier, isExtension, position);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TokensResponseTokens {\n");
    
    sb.append("    word: ").append(toIndentedString(word)).append("\n");
    sb.append("    lemma: ").append(toIndentedString(lemma)).append("\n");
    sb.append("    partOfSpeech: ").append(toIndentedString(partOfSpeech)).append("\n");
    sb.append("    modifier: ").append(toIndentedString(modifier)).append("\n");
    sb.append("    isExtension: ").append(toIndentedString(isExtension)).append("\n");
    sb.append("    position: ").append(toIndentedString(position)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

